#!/usr/bin/env ts-node

import crypto from "node:crypto";

interface Endpoint {
  method: string;
  path: string;
  body?: Record<string, unknown>;
  description: string;
  expectJson?: boolean;
}

const DEFAULT_BASE_URL = process.env.BASE_URL || process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
const baseUrl = process.argv[2] || DEFAULT_BASE_URL;

const endpoints: Endpoint[] = [
  { method: "GET", path: "/api/blogs", description: "List published blogs", expectJson: true },
  { method: "GET", path: "/api/videos", description: "List published videos", expectJson: true },
  { method: "GET", path: "/api/categories", description: "Category index", expectJson: true },
  { method: "GET", path: "/api/comments?postId=test&postType=blog", description: "Comments listing", expectJson: true },
  {
    method: "POST",
    path: "/api/contact",
    description: "Submit contact form",
    expectJson: true,
    body: {
      firstName: "Smoke",
      lastName: "Test",
      email: "smoke@example.com",
      subject: "API Smoke Test",
      message: "This is a synthetic request generated by scripts/smoke-api.ts.",
    },
  },
  {
    method: "POST",
    path: "/api/comments",
    description: "Submit comment",
    expectJson: true,
    body: {
      author: "Smoke Test",
      content: "Synthetic comment from scripts/smoke-api.ts",
      postId: "test-post",
      postType: "blog",
    },
  },
];

function prettyDuration(ms: number): string {
  return `${ms.toFixed(0)}ms`;
}

async function run() {
  console.log(`\nAPI smoke test against ${baseUrl}`);
  console.log("--------------------------------------");

  for (const endpoint of endpoints) {
    const url = new URL(endpoint.path, baseUrl);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 15000);
    const requestId = crypto.randomUUID();
    const start = performance.now();

    try {
      const res = await fetch(url, {
        method: endpoint.method,
        cache: "no-store",
        headers: {
          "Content-Type": endpoint.body ? "application/json" : "application/json",
          "X-Request-ID": requestId,
        },
        body: endpoint.body ? JSON.stringify(endpoint.body) : undefined,
        signal: controller.signal,
      });
      const duration = performance.now() - start;
      let jsonValid = false;
      let bodySnippet = "";

      if (endpoint.expectJson) {
        try {
          const data = await res.clone().json();
          jsonValid = true;
          bodySnippet = JSON.stringify(data).slice(0, 120);
        } catch (error) {
          jsonValid = false;
          bodySnippet = `Invalid JSON (${(error as Error).message})`;
        }
      } else {
        bodySnippet = await res.clone().text().then((text) => text.slice(0, 120));
      }

      console.log(
        `${endpoint.method.padEnd(6)} ${endpoint.path.padEnd(40)} ${res.status.toString().padEnd(4)} ${prettyDuration(duration).padStart(6)} ` +
          `${jsonValid ? "JSON" : "TEXT"} – ${endpoint.description}`,
      );
      if (!res.ok || !jsonValid) {
        console.log(`  ↳ Response snippet: ${bodySnippet}`);
      }
    } catch (error) {
      console.error(
        `${endpoint.method.padEnd(6)} ${endpoint.path.padEnd(40)} ERR  ${(performance.now() - start).toFixed(0).padStart(6)}ms – ${endpoint.description}`,
      );
      console.error(`  ↳ ${(error as Error).message}`);
    } finally {
      clearTimeout(timeout);
    }
  }
}

run().catch((error) => {
  console.error("Smoke test failed", error);
  process.exitCode = 1;
});